<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8">
  <title>CMP – Courbe de montée en puissance (SDIS 27)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <style>
    body{
      margin:0;
      font-family:system-ui, Arial, sans-serif;
      background:#f5f7fa;
      color:#111;
      line-height:1.5;
    }
    header{
      background:#0b1220;
      color:#fff;
      padding:18px 14px;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:12px;
    }
    header .title{
      font-weight:900;
      font-size:1.1rem;
    }
    header a{
      color:#fff;
      text-decoration:none;
      font-weight:800;
      padding:10px 12px;
      border-radius:10px;
      background:rgba(255,255,255,0.12);
      white-space:nowrap;
    }
    main{
      max-width:980px;
      margin:auto;
      padding:16px 12px 26px;
    }
    .card{
      background:#fff;
      border:1px solid #ddd;
      border-radius:14px;
      padding:14px;
      margin-top:12px;
    }
    .card h2{
      margin:0 0 10px 0;
      font-size:1.1rem;
      font-weight:900;
    }
    .grid{
      display:grid;
      grid-template-columns: 1fr 1fr 1fr 1fr;
      gap:10px;
      align-items:end;
    }
    @media (max-width:720px){
      .grid{ grid-template-columns: 1fr 1fr; }
    }
    label{ font-weight:800; font-size:0.95rem; }
    input, select, button{
      width:100%;
      padding:10px;
      border-radius:10px;
      border:1px solid #ccc;
      box-sizing:border-box;
      font-family:inherit;
      font-size:1rem;
    }
    .row{
      display:flex;
      gap:10px;
      margin-top:10px;
      flex-wrap:wrap;
    }
    .btn{
      cursor:pointer;
      font-weight:900;
      border:0;
      border-radius:12px;
      padding:12px 14px;
    }
    .btn-primary{ background:#2563eb; color:#fff; }
    .btn-ghost{ background:#fff; border:1px solid #ccc; }
    .small{ font-size:12px; color:#555; margin-top:6px; }
    .warn{
      background:#fff3cd;
      border:1px solid #ffeeba;
      padding:10px 12px;
      border-radius:12px;
      font-size:0.95rem;
    }

    table{
      width:100%;
      border-collapse:separate;
      border-spacing:0;
      overflow:hidden;
      border:1px solid #e5e7eb;
      border-radius:12px;
      margin-top:10px;
    }
    th, td{
      padding:10px;
      border-bottom:1px solid #e5e7eb;
      text-align:left;
      font-size:0.95rem;
      vertical-align:middle;
    }
    th{ background:#f8fafc; font-weight:900; }
    tr:last-child td{ border-bottom:none; }

    .pill{
      display:inline-block;
      padding:6px 10px;
      border-radius:999px;
      font-weight:900;
      font-size:0.85rem;
      border:1px solid #ddd;
      background:#f8fafc;
    }

    .canvas-wrap{
      width:100%;
      overflow:auto;
      border:1px dashed #cbd5e1;
      border-radius:12px;
      padding:10px;
      background:#fff;
    }
    canvas{ width:100%; height:auto; }
  </style>
</head>

<body>
<header>
  <div class="title">CMP – Courbe de montée en puissance (SDIS 27)</div>
  <a href="calcul.html">← Retour calcul</a>
</header>

<main>

  <div class="card" id="blocStatus">
    <h2>Paramètres importés depuis le calcul</h2>
    <div id="status" class="warn">Chargement…</div>
    <div class="small">La CMP est disponible uniquement si tu viens depuis le calcul en mode SDIS 27.</div>
  </div>

  <div class="card" id="blocSaisie" style="display:none;">
    <h2>Saisie des engins (arrivée échelonnée)</h2>

    <div class="grid">
      <div>
        <label>Type d’engin</label>
        <select id="enginType">
          <option value="FPT">FPT</option>
          <option value="CCRM">CCRM</option>
          <option value="CCR">CCR</option>
          <option value="CCGC">CCGC</option>
          <option value="CCGCM">CCGCM</option>
          <option value="CED">CED</option>
          <option value="CEDEM">CEDEM</option>
          <option value="CDHR">CDHR</option>
          <option value="CEEM">CEEM (émulseur)</option>
        </select>
        <div class="small">Débit solution + stock émulseur selon table SDIS 27.</div>
      </div>

      <div>
        <label>Heure d’arrivée (hh:mm)</label>
        <input id="arrivee" type="time" value="00:00">
        <div class="small">00:00 = sur place immédiat.</div>
      </div>

      <div>
        <label>Quantité</label>
        <input id="qty" type="number" min="1" step="1" value="1">
      </div>

      <div>
        <button id="btnAdd" class="btn btn-primary" type="button">Ajouter</button>
      </div>
    </div>

    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Arrivée</th>
          <th>Qté</th>
          <th>Débit (L/min)</th>
          <th>Émulseur (L)</th>
          <th></th>
        </tr>
      </thead>
      <tbody id="liste"></tbody>
    </table>

    <div class="row">
      <button id="btnTracer" class="btn btn-primary" type="button">Tracer la courbe</button>
      <button id="btnReset" class="btn btn-ghost" type="button">Tout effacer</button>
    </div>

    <div class="small">
      Logique : TEMPORISATION tant que débit dispo &lt; Q ext OU stock émulseur &lt; besoin extinction.
      Consommation émulseur = 3% du débit utilisé (Q tempo / Q ext).
    </div>
  </div>

  <div class="card" id="blocCourbe" style="display:none;">
    <h2>Courbe (T0 → T0+5h, pas 20 min)</h2>
    <div class="row" style="align-items:center;">
      <span class="pill" id="pillQext">Q ext : —</span>
      <span class="pill" id="pillQtempo">Q tempo : —</span>
      <span class="pill" id="pilltExt">Durée ext. : —</span>
      <span class="pill" id="pillBesoin">Besoin extinction : —</span>
      <span class="pill" id="pillT0">T0 : —</span>
    </div>

    <div class="canvas-wrap" style="margin-top:10px;">
      <canvas id="chart" width="1100" height="520"></canvas>
    </div>

    <div class="small">
      Axe gauche : débit solution (L/min). Axe droit : stock émulseur (L). Pointillés : Q ext (cible).
    </div>
  </div>

</main>

<script>
(() => {
  const $ = (id) => document.getElementById(id);
// ===== CMP : constantes =====
const STEP_MIN = 20;
const HORIZON_H = 5;
const HORIZON_MIN = HORIZON_H * 60;

const pad2 = (x) => String(x).padStart(2, "0");

const timeToMin = (hhmm) => {
  if (!hhmm) return NaN;
  const [h, m] = hhmm.split(":").map(Number);
  if (![h, m].every(Number.isFinite)) return NaN;
  return h * 60 + m;
};

// T0 = arrivée la plus tôt (en minutes "horloge")
const getFirstArrivalMin = (rows) => {
  let best = Infinity;
  rows.forEach(r => {
    const m = timeToMin(r.atStr);
    if (Number.isFinite(m)) best = Math.min(best, m);
  });
  return best === Infinity ? NaN : best;
};

// minutes relatives depuis T0 (gère passage minuit)
const arrivalRelMin = (hhmm, t0) => {
  const m = timeToMin(hhmm);
  if (!Number.isFinite(m) || !Number.isFinite(t0)) return NaN;
  let rel = m - t0;
  if (rel < 0) rel += 24 * 60;
  return rel;
};

const addMinToHHMM = (hhmm, add) => {
  const base = timeToMin(hhmm);
  if (!Number.isFinite(base)) return "??:??";
  let total = (base + add) % (24 * 60);
  if (total < 0) total += 24 * 60;
  const h = Math.floor(total / 60);
  const m = total % 60;
  return `${pad2(h)}:${pad2(m)}`;
};

// labels X : toutes les 20 minutes de T0 à T0+5h
const buildTimeLabels = (t0MinAbs) => {
  const t0 = `${pad2(Math.floor(t0MinAbs / 60))}:${pad2(t0MinAbs % 60)}`;
  const labels = [];
  for (let t = 0; t <= HORIZON_MIN; t += STEP_MIN) {
    labels.push(addMinToHHMM(t0, t));
  }
  return labels;
};

  // =========================
  // Étape A — Temps (T0 + pas)
  // =========================
  const STEP_MIN = 20;      // pas de 20 minutes
  const HORIZON_H = 5;      // jusqu'à T0 + 5h
  const HORIZON_MIN = HORIZON_H * 60;

  const pad2 = (n) => String(n).padStart(2, "0");

  // "hh:mm" -> minutes dans la journée (0..1439)
  function hhmmToMin(hhmm) {
    if (!hhmm || !/^\d{2}:\d{2}$/.test(hhmm)) return NaN;
    const [h, m] = hhmm.split(":").map(Number);
    if (h < 0 || h > 23 || m < 0 || m > 59) return NaN;
    return h * 60 + m;
  }

  // minutes -> "hh:mm" (boucle sur 24h)
  function minToHHMM(min) {
    const mm = ((min % 1440) + 1440) % 1440;
    const h = Math.floor(mm / 60);
    const m = mm % 60;
    return `${pad2(h)}:${pad2(m)}`;
  }

  // Trouve l'heure d'arrivée la + tôt
  function getFirstArrivalMin(engins) {
    const mins = engins
      .map(e => hhmmToMin(e.atStr))
      .filter(Number.isFinite);
    return mins.length ? Math.min(...mins) : NaN;
  }

  // "arrivée hh:mm" -> minutes relatives depuis T0 (gestion simple passage minuit)
  function arrivalRelMin(arriveeHHMM, t0Min) {
    const a = hhmmToMin(arriveeHHMM);
    if (!Number.isFinite(a)) return NaN;
    let rel = a - t0Min;
    if (rel < 0) rel += 1440;
    return rel;
  }

  // Labels X : de T0 à T0+5h par pas de 20 min
  function buildTimeLabels(t0Min) {
    const totalSteps = Math.round(HORIZON_MIN / STEP_MIN); // 300/20=15
    const labels = [];
    for (let i = 0; i <= totalSteps; i++) {
      labels.push(minToHHMM(t0Min + i * STEP_MIN));
    }
    return labels;
  }

  // =========================
  // Données SDIS 27
  // =========================
  const ENGINS = {
    FPT:   { flow: 2000, emul: 200 },
    CCRM:  { flow: 1500, emul: 200 },
    CCR:   { flow: 1000, emul: 40  },
    CCGC:  { flow: 1000, emul: 0   },
    CCGCM: { flow: 3000, emul: 1200 },
    CED:   { flow: 4000, emul: 0   },
    CEDEM: { flow: 4000, emul: 2000 },
    CDHR:  { flow: 4000, emul: 0   },
    CEEM:  { flow: 0,    emul: 6000 }
  };

  const n = (v) => {
    if (v === null || v === undefined) return NaN;
    const s = String(v).replace(",", ".").trim();
    if (!s) return NaN;
    const x = Number(s);
    return Number.isFinite(x) ? x : NaN;
  };

  // =========================
  // Charge paramètres calcul
  // =========================
  let params = null;
  try {
    params = JSON.parse(localStorage.getItem("LIF_CMP_INPUTS") || "null");
  } catch (e) { params = null; }

  const status = $("status");
  const blocSaisie = $("blocSaisie");
  const blocCourbe = $("blocCourbe");

  if (!params || params.mode !== "lock") {
    status.textContent = "Impossible : aucun calcul SDIS 27 n’a été transmis. Retourne sur la page calcul, fais un calcul en mode SDIS 27, puis clique sur “Courbe de montée en puissance”.";
    return;
  }

  status.innerHTML =
    `✅ Paramètres reçus :<br>
     - Q ext = <b>${Math.round(params.Qext)}</b> L/min<br>
     - Q tempo = <b>${Math.round(params.Qtempo)}</b> L/min<br>
     - Durée ext. = <b>${Math.round(params.tExt)}</b> min<br>
     - Concentration = <b>${params.concPct}%</b><br>
     - Besoin extinction = <b>${Math.round(params.besoinExt)}</b> L émulseur`;
  blocSaisie.style.display = "block";

  // =========================
  // Liste d'engins
  // =========================
  const rows = []; // {type, atStr, qty}
  const tbody = $("liste");

  const render = () => {
    tbody.innerHTML = "";
    rows.forEach((r, idx) => {
      const def = ENGINS[r.type];
      const flow = def.flow * r.qty;
      const emul = def.emul * r.qty;

      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td><b>${r.type}</b></td>
        <td>${r.atStr}</td>
        <td>${r.qty}</td>
        <td>${flow}</td>
        <td>${emul}</td>
        <td><button data-i="${idx}" class="btn btn-ghost" style="padding:8px 10px;">Supprimer</button></td>
      `;
      tbody.appendChild(tr);
    });

    tbody.querySelectorAll("button[data-i]").forEach(btn => {
      btn.addEventListener("click", () => {
        const i = Number(btn.getAttribute("data-i"));
        rows.splice(i, 1);
        render();
      });
    });
  };

  $("btnAdd").addEventListener("click", () => {
    const type = $("enginType").value;
    const atStr = $("arrivee").value || "00:00";
    const qty = Math.max(1, Math.floor(n($("qty").value) || 1));

    if (!ENGINS[type]) return;
    if (!Number.isFinite(hhmmToMin(atStr))) {
      alert("Heure d’arrivée invalide.");
      return;
    }

    rows.push({ type, atStr, qty });

    // tri simple par heure dans la journée (utile visuellement)
    rows.sort((a,b) => hhmmToMin(a.atStr) - hhmmToMin(b.atStr));
    render();
  });

  $("btnReset").addEventListener("click", () => {
    rows.length = 0;
    render();
    blocCourbe.style.display = "none";
  });

  // =========================
  // Simulation minute par minute (T0 → T0+5h)
  // =========================
function simulate() {
  const Qext = params.Qext;          // L/min
  const Qtempo = params.Qtempo;      // L/min
  const tExt = params.tExt;          // min
  const conc = (params.concPct / 100);

  const needExtTotal = Qext * tExt * conc; // L d’émulseur nécessaires

  // T0 = arrivée la + tôt
  const t0Abs = getFirstArrivalMin(rows);
  if (!Number.isFinite(t0Abs)) {
    throw new Error("Impossible : aucune arrivée valide.");
  }

  // Ajouts minute (0..HORIZON_MIN)
  const addFlow = Array(HORIZON_MIN + 1).fill(0); // débit dispo ajouté
  const addEmul = Array(HORIZON_MIN + 1).fill(0); // stock ajouté

  rows.forEach(r => {
    const def = ENGINS[r.type];
    const rel = arrivalRelMin(r.atStr, t0Abs); // minute relative depuis T0
    if (!Number.isFinite(rel)) return;

    const m = Math.min(HORIZON_MIN, Math.max(0, Math.round(rel)));
    addFlow[m] += def.flow * r.qty;
    addEmul[m] += def.emul * r.qty;
  });

  let flowAvail = 0;   // débit dispo cumulé
  let emulStock = 0;   // stock dispo cumulé

  let startedExt = false;
  let extRemaining = 0;

  let tStockOK = null;    // 1ère minute où stock >= besoin extinction
  let tExtStart = null;   // 1ère minute où (débit>=Qext && stock>=besoin)

  // séries minute
  const flowAvailSerie = Array(HORIZON_MIN + 1).fill(0); // NOIR = débit dispo (escaliers)
  const emulSerie = Array(HORIZON_MIN + 1).fill(0);      // ROUGE = stock dispo (escaliers)

  for (let t = 0; t <= HORIZON_MIN; t++) {
    // Arrivées => marches immédiates
    flowAvail += addFlow[t];
    emulStock += addEmul[t];

    // repère "stock OK"
    if (tStockOK === null && emulStock >= needExtTotal) tStockOK = t;

    // Conditions de bascule extinction
    const canFlow = flowAvail >= Qext;
    const canEmul = emulStock >= needExtTotal;

    if (!startedExt && canFlow && canEmul) {
      startedExt = true;
      extRemaining = tExt;
      tExtStart = t;
    }

    // ===== consommation d’émulseur =====
    // TEMPORISATION tant que pas en extinction : conso = Qtempo * 3%
    // EXTINCTION : conso = Qext * 3% pendant tExt
    let emulCons = 0;

    if (!startedExt) {
      emulCons = Qtempo * conc; // L/min d'émulseur
    } else if (extRemaining > 0) {
      emulCons = Qext * conc;
      extRemaining -= 1;
    } else {
      emulCons = 0;
    }

    // on ne consomme pas au-delà du stock
    if (emulCons > emulStock) emulCons = emulStock;
    emulStock -= emulCons;

    flowAvailSerie[t] = flowAvail;
    emulSerie[t] = emulStock;
  }

  const labels = buildTimeLabels(t0Abs);

  return {
    Qext, Qtempo, tExt, concPct: params.concPct,
    needExtTotal,
    t0Abs,
    labels,
    tStockOK,
    tExtStart,
    flowAvailSerie,
    emulSerie
  };
}

  // =========================
  // Dessin canvas (débit L/min + stock L)
  // =========================
  function drawChart(data) {
    const c = $("chart");
    const ctx = c.getContext("2d");

    const W = c.width, H = c.height;
    ctx.clearRect(0,0,W,H);

    // Marges
    const mL = 85, mR = 85, mT = 40, mB = 70;
    const plotW = W - mL - mR;
    const plotH = H - mT - mB;

    // Domaines
    const xMax = HORIZON_MIN;
    const yFlowMax = Math.max(data.Qext, ...data.flow20) * 1.2 || 1000; // L/min
    const yEmulMax = Math.max(...data.emul20, 1) * 1.2;

    const x = (t) => mL + (t / xMax) * plotW;
    const yFlow = (v) => mT + (1 - (v / yFlowMax)) * plotH;
    const yEmul = (v) => mT + (1 - (v / yEmulMax)) * plotH;

    // Cadre
    ctx.lineWidth = 1;
    ctx.strokeStyle = "#cbd5e1";
    ctx.strokeRect(mL, mT, plotW, plotH);

    // Grille verticale (tous les 20 min)
    ctx.strokeStyle = "#e5e7eb";
    for (let t=0; t<=HORIZON_MIN; t+=STEP_MIN){
      ctx.beginPath();
      ctx.moveTo(x(t), mT);
      ctx.lineTo(x(t), mT+plotH);
      ctx.stroke();
    }

    // Axe X labels (hh:mm)
    ctx.fillStyle = "#111";
    ctx.font = "12px system-ui, Arial";
    for (let t=0; t<=HORIZON_MIN; t+=STEP_MIN){
      const idx = Math.round(t / STEP_MIN);
      const label = data.labels[idx] || "";
      ctx.fillText(label, x(t)-16, mT+plotH+22);
    }
    ctx.fillText(`Temps (T0 → T0+${HORIZON_H}h, pas ${STEP_MIN} min)`, mL, H-18);

    // Axe Y gauche (débit L/min)
    ctx.fillStyle = "#111";
    ctx.fillText("Débit solution (L/min)", 10, 18);
    for (let i=0;i<=5;i++){
      const v = (yFlowMax * i/5);
      const yy = yFlow(v);
      ctx.strokeStyle = "#e5e7eb";
      ctx.beginPath(); ctx.moveTo(mL, yy); ctx.lineTo(mL+plotW, yy); ctx.stroke();
      ctx.fillStyle = "#111";
      ctx.fillText(Math.round(v).toString(), 10, yy+4);
    }

    // Axe Y droit (stock émulseur)
    ctx.fillStyle = "#111";
    ctx.fillText("Stock émulseur (L)", W-180, 18);
    for (let i=0;i<=5;i++){
      const v = (yEmulMax * i/5);
      const yy = yEmul(v);
      ctx.fillText(Math.round(v).toString(), W-78, yy+4);
    }

    // Courbe débit (noir)
    ctx.strokeStyle = "#111";
    ctx.lineWidth = 2;
    ctx.beginPath();
    data.ticks.forEach((t, i) => {
      const xx = x(t);
      const yy = yFlow(data.flow20[i]);
      if (i===0) ctx.moveTo(xx, yy);
      else ctx.lineTo(xx, yy);
    });
    ctx.stroke();

    // Courbe stock émulseur (rouge)
    ctx.strokeStyle = "#ef4444";
    ctx.lineWidth = 2;
    ctx.beginPath();
    data.ticks.forEach((t, i) => {
      const xx = x(t);
      const yy = yEmul(data.emul20[i]);
      if (i===0) ctx.moveTo(xx, yy);
      else ctx.lineTo(xx, yy);
    });
    ctx.stroke();

    // Ligne cible Qext (pointillés)
    ctx.strokeStyle = "#2563eb";
    ctx.setLineDash([6,6]);
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(mL, yFlow(data.Qext));
    ctx.lineTo(mL+plotW, yFlow(data.Qext));
    ctx.stroke();
    ctx.setLineDash([]);

    // Légende
    ctx.fillStyle = "#111";
    ctx.fillText("— Débit utilisé", mL+10, mT+16);
    ctx.fillStyle = "#ef4444";
    ctx.fillText("— Stock émulseur", mL+120, mT+16);
    ctx.fillStyle = "#2563eb";
    ctx.fillText("— Q ext (cible)", mL+260, mT+16);
  }

  $("btnTracer").addEventListener("click", () => {
    if (rows.length === 0) {
      alert("Ajoute au moins un engin (ex : 1 FPT à 00:00).");
      return;
    }

    let data;
    try {
      data = simulate();
    } catch (e) {
      alert(e.message || "Erreur simulation.");
      return;
    }

    $("pillQext").textContent = `Q ext : ${Math.round(data.Qext)} L/min`;
    $("pillQtempo").textContent = `Q tempo : ${Math.round(data.Qtempo)} L/min`;
    $("pilltExt").textContent = `Durée ext. : ${Math.round(data.tExt)} min`;
    $("pillBesoin").textContent = `Besoin extinction : ${Math.round(data.needExtTotal)} L`;
    $("pillT0").textContent = `T0 : ${minToHHMM(data.t0)}`;

    blocCourbe.style.display = "block";
    drawChart(data);

    blocCourbe.scrollIntoView({ behavior: "smooth", block: "start" });
  });

  render();
})();
</script>

</body>
</html>
