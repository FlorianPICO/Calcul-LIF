<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8">
  <title>CMP – Courbe de montée en puissance (SDIS 27)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <style>
    body{ margin:0; font-family:system-ui, Arial, sans-serif; background:#f5f7fa; color:#111; line-height:1.5; }
    header{ background:#0b1220; color:#fff; padding:18px 14px; display:flex; align-items:center; justify-content:space-between; gap:12px; }
    header .title{ font-weight:900; font-size:1.1rem; }
    header a{ color:#fff; text-decoration:none; font-weight:800; padding:10px 12px; border-radius:10px; background:rgba(255,255,255,0.12); white-space:nowrap; }
    main{ max-width:980px; margin:auto; padding:16px 12px 26px; }
    .card{ background:#fff; border:1px solid #ddd; border-radius:14px; padding:14px; margin-top:12px; }
    .card h2{ margin:0 0 10px 0; font-size:1.1rem; font-weight:900; }
    .grid{ display:grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap:10px; align-items:end; }
    @media (max-width:720px){ .grid{ grid-template-columns: 1fr 1fr; } }
    label{ font-weight:800; font-size:0.95rem; }
    input, select, button{ width:100%; padding:10px; border-radius:10px; border:1px solid #ccc; box-sizing:border-box; font-family:inherit; font-size:1rem; }
    .row{ display:flex; gap:10px; margin-top:10px; flex-wrap:wrap; }
    .btn{ cursor:pointer; font-weight:900; border:0; border-radius:12px; padding:12px 14px; }
    .btn-primary{ background:#2563eb; color:#fff; }
    .btn-ghost{ background:#fff; border:1px solid #ccc; }
    .small{ font-size:12px; color:#555; margin-top:6px; }
    .warn{ background:#fff3cd; border:1px solid #ffeeba; padding:10px 12px; border-radius:12px; font-size:0.95rem; }

    table{ width:100%; border-collapse:separate; border-spacing:0; overflow:hidden; border:1px solid #e5e7eb; border-radius:12px; margin-top:10px; }
    th, td{ padding:10px; border-bottom:1px solid #e5e7eb; text-align:left; font-size:0.95rem; vertical-align:middle; }
    th{ background:#f8fafc; font-weight:900; }
    tr:last-child td{ border-bottom:none; }

    .pill{ display:inline-block; padding:6px 10px; border-radius:999px; font-weight:900; font-size:0.85rem; border:1px solid #ddd; background:#f8fafc; }

    .canvas-wrap{ width:100%; overflow:auto; border:1px dashed #cbd5e1; border-radius:12px; padding:10px; background:#fff; }
    canvas{ width:100%; height:auto; }
  </style>
</head>

<body>
<header>
  <div class="title">CMP – Courbe de montée en puissance (SDIS 27)</div>
  <a href="calcul.html">← Retour calcul</a>
</header>

<main>
  <div class="card" id="blocStatus">
    <h2>Paramètres importés depuis le calcul</h2>
    <div id="status" class="warn">Chargement…</div>
    <div class="small">La CMP est disponible uniquement si tu viens depuis le calcul en mode SDIS 27.</div>
  </div>

  <div class="card" id="blocSaisie" style="display:none;">
    <h2>Saisie des engins (arrivée échelonnée)</h2>

    <div class="grid">
      <div>
        <label>Type d’engin</label>
        <select id="enginType">
          <option value="FPT">FPT</option>
          <option value="CCRM">CCRM</option>
          <option value="CCR">CCR</option>
          <option value="CCGC">CCGC</option>
          <option value="CCGCM">CCGCM</option>
          <option value="CED">CED</option>
          <option value="CEDEM">CEDEM</option>
          <option value="CDHR">CDHR</option>
          <option value="CEEM">CEEM (émulseur)</option>
        </select>
        <div class="small">Débit solution + stock émulseur selon table SDIS 27.</div>
      </div>

      <div>
        <label>Heure d’arrivée (hh:mm)</label>
        <input id="arrivee" type="time" value="00:00">
        <div class="small">00:00 = sur place immédiat.</div>
      </div>

      <div>
        <label>Quantité</label>
        <input id="qty" type="number" min="1" step="1" value="1">
      </div>

      <div>
        <button id="btnAdd" class="btn btn-primary" type="button">Ajouter</button>
      </div>
    </div>

    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Arrivée</th>
          <th>Qté</th>
          <th>Débit (L/min)</th>
          <th>Émulseur (L)</th>
          <th></th>
        </tr>
      </thead>
      <tbody id="liste"></tbody>
    </table>

    <div class="row">
      <button id="btnTracer" class="btn btn-primary" type="button">Tracer la courbe</button>
      <button id="btnReset" class="btn btn-ghost" type="button">Tout effacer</button>
    </div>

    <div class="small">
      Logique : TEMPORISATION tant que débit dispo &lt; Q ext OU stock émulseur &lt; besoin extinction.
      Temporisation : conso = Q tempo × 3%. Extinction : conso = Q ext × 3% pendant Durée ext.
    </div>
  </div>

  <div class="card" id="blocCourbe" style="display:none;">
    <h2>5) Courbe de montée en puissance</h2>

    <div class="row" style="align-items:center;">
      <span class="pill" id="pillQext">Q ext : —</span>
      <span class="pill" id="pillQtempo">Q tempo : —</span>
      <span class="pill" id="pilltExt">Durée ext. : —</span>
      <span class="pill" id="pillBesoin">Besoin en émulseur pour extinction : —</span>
      <span class="pill" id="pillT0">T0 : —</span>
      <span class="pill" id="pillStockOK">Stock OK : —</span>
      <span class="pill" id="pillExtStart">Début extinction : —</span>
      <span class="pill" id="pillExtEnd">Fin extinction : —</span>
    </div>

    <div class="canvas-wrap" style="margin-top:10px;">
      <canvas id="chart" width="1100" height="520"></canvas>
    </div>
<div id="extIndicators" style="display:flex; gap:10px; justify-content:center; flex-wrap:wrap; margin-top:-10px;">
  <span id="extIndStart" style="display:inline-flex; align-items:center; justify-content:center; padding:6px 10px; border-radius:999px; font-weight:900; font-size:12px; border:2px solid #16a34a; background:rgba(22,163,74,0.10); color:#166534;">
    Début ext. : —
  </span>
  <span id="extIndEnd" style="display:inline-flex; align-items:center; justify-content:center; padding:6px 10px; border-radius:999px; font-weight:900; font-size:12px; border:2px solid #16a34a; background:rgba(22,163,74,0.10); color:#166534;">
    Fin ext. : —
  </span>
</div>

    <div class="small">
      Axe gauche : débit solution (L/min). Axe droit : stock émulseur (L). Courbes en escaliers.
      Marqueurs : Stock OK (≥ besoin extinction) et Début extinction (débit ≥ Q ext ET stock ≥ besoin).
    </div>
  </div>
</main>

<script>
(() => {
  const $ = (id) => document.getElementById(id);

  // ===== Paramètres CMP =====
  const STEP_MIN = 20;
  const HORIZON_H = 5;
  const HORIZON_MIN = HORIZON_H * 60;

  const pad2 = (x) => String(x).padStart(2, "0");

  // minutes -> "hh:mm" (boucle 24h)
  const minToHHMM = (min) => {
    const mm = ((min % 1440) + 1440) % 1440;
    const h = Math.floor(mm / 60);
    const m = mm % 60;
    return `${pad2(h)}:${pad2(m)}`;
  };

  const n = (v) => {
    if (v === null || v === undefined) return NaN;
    const s = String(v).replace(",", ".").trim();
    if (!s) return NaN;
    const x = Number(s);
    return Number.isFinite(x) ? x : NaN;
  };

  const timeToMin = (hhmm) => {
    if (!hhmm || !/^\d{2}:\d{2}$/.test(hhmm)) return NaN;
    const [h, m] = hhmm.split(":").map(Number);
    if (h < 0 || h > 23 || m < 0 || m > 59) return NaN;
    return h * 60 + m;
  };

  const addMinToHHMM = (hhmm, add) => {
    const base = timeToMin(hhmm);
    if (!Number.isFinite(base)) return "??:??";
    let total = (base + add) % (24 * 60);
    if (total < 0) total += 24 * 60;
    const h = Math.floor(total / 60);
    const m = total % 60;
    return `${pad2(h)}:${pad2(m)}`;
  };

  const getFirstArrivalMin = (rows) => {
    let best = Infinity;
    rows.forEach(r => {
      const m = timeToMin(r.atStr);
      if (Number.isFinite(m)) best = Math.min(best, m);
    });
    return best === Infinity ? NaN : best;
  };

  const arrivalRelMin = (hhmm, t0) => {
    const m = timeToMin(hhmm);
    if (!Number.isFinite(m) || !Number.isFinite(t0)) return NaN;
    let rel = m - t0;
    if (rel < 0) rel += 24 * 60;
    return rel;
  };

  const buildTimeLabels = (t0MinAbs) => {
    const t0 = `${pad2(Math.floor(t0MinAbs / 60))}:${pad2(t0MinAbs % 60)}`;
    const labels = [];
    for (let t = 0; t <= HORIZON_MIN; t += STEP_MIN) labels.push(addMinToHHMM(t0, t));
    return labels;
  };

  // ===== Engins =====
  const ENGINS = {
    FPT:   { flow: 2000, emul: 200 },
    CCRM:  { flow: 1500, emul: 200 },
    CCR:   { flow: 1000, emul: 40  },
    CCGC:  { flow: 1000, emul: 0   },
    CCGCM: { flow: 3000, emul: 1200 },
    CED:   { flow: 4000, emul: 0   },
    CEDEM: { flow: 4000, emul: 2000 },
    CDHR:  { flow: 4000, emul: 0   },
    CEEM:  { flow: 0,    emul: 6000 }
  };

  // ===== Charge params =====
  let params = null;
  try { params = JSON.parse(localStorage.getItem("LIF_CMP_INPUTS") || "null"); }
  catch (e) { params = null; }

  const status = $("status");
  const blocSaisie = $("blocSaisie");
  const blocCourbe = $("blocCourbe");

  if (!params || params.mode !== "lock") {
    status.textContent = "Impossible : aucun calcul SDIS 27 n’a été transmis. Retourne sur la page calcul, fais un calcul en mode SDIS 27, puis clique sur “Courbe de montée en puissance”.";
    return;
  }

  status.innerHTML =
    `✅ Paramètres reçus :<br>
     - Q ext = <b>${Math.round(params.Qext)}</b> L/min<br>
     - Q tempo = <b>${Math.round(params.Qtempo)}</b> L/min<br>
     - Durée ext. = <b>${Math.round(params.tExt)}</b> min<br>
     - Concentration = <b>${params.concPct}%</b><br>
     - Besoin extinction = <b>${Math.round(params.besoinExt)}</b> L émulseur`;
  blocSaisie.style.display = "block";

  // ===== Liste engins =====
  const rows = [];
  const tbody = $("liste");

  const render = () => {
    tbody.innerHTML = "";
    rows.forEach((r, idx) => {
      const def = ENGINS[r.type];
      const flow = def.flow * r.qty;
      const emul = def.emul * r.qty;

      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td><b>${r.type}</b></td>
        <td>${r.atStr}</td>
        <td>${r.qty}</td>
        <td>${flow}</td>
        <td>${emul}</td>
        <td><button data-i="${idx}" class="btn btn-ghost" style="padding:8px 10px;">Supprimer</button></td>
      `;
      tbody.appendChild(tr);
    });

    tbody.querySelectorAll("button[data-i]").forEach(btn => {
      btn.addEventListener("click", () => {
        const i = Number(btn.getAttribute("data-i"));
        rows.splice(i, 1);
        render();
      });
    });
  };

  $("btnAdd").addEventListener("click", () => {
    const type = $("enginType").value;
    const atStr = $("arrivee").value || "00:00";
    const qty = Math.max(1, Math.floor(n($("qty").value) || 1));

    if (!ENGINS[type]) return;
    if (!Number.isFinite(timeToMin(atStr))) { alert("Heure d’arrivée invalide."); return; }

    rows.push({ type, atStr, qty });
    rows.sort((a,b) => timeToMin(a.atStr) - timeToMin(b.atStr));
    render();
  });

  $("btnReset").addEventListener("click", () => {
    rows.length = 0;
    render();
    blocCourbe.style.display = "none";
  });

  // ===== Simulation =====
  function simulate() {
    const Qext = params.Qext;
    const Qtempo = params.Qtempo;
    const tExt = params.tExt;
    const conc = (params.concPct / 100);

    const needExtTotal = Qext * tExt * conc;

    const t0Abs = getFirstArrivalMin(rows);
    if (!Number.isFinite(t0Abs)) throw new Error("Impossible : aucune arrivée valide.");

    const addFlow = Array(HORIZON_MIN + 1).fill(0);
    const addEmul = Array(HORIZON_MIN + 1).fill(0);

    rows.forEach(r => {
      const def = ENGINS[r.type];
      const rel = arrivalRelMin(r.atStr, t0Abs);
      if (!Number.isFinite(rel)) return;
      const m = Math.min(HORIZON_MIN, Math.max(0, Math.round(rel)));
      addFlow[m] += def.flow * r.qty;
      addEmul[m] += def.emul * r.qty;
    });

    let flowAvail = 0;
    let emulStock = 0;

    let startedExt = false;
    let extRemaining = 0;

    let tStockOK = null;
    let tExtStart = null;

    const flowAvailSerie = Array(HORIZON_MIN + 1).fill(0);
    const emulSerie = Array(HORIZON_MIN + 1).fill(0);

    for (let t = 0; t <= HORIZON_MIN; t++) {
      flowAvail += addFlow[t];
      emulStock += addEmul[t];

      if (tStockOK === null && emulStock >= needExtTotal) tStockOK = t;

      const canFlow = flowAvail >= Qext;
      const canEmul = emulStock >= needExtTotal;

      if (!startedExt && canFlow && canEmul) {
        startedExt = true;
        extRemaining = tExt;
        tExtStart = t;
      }

      let emulCons = 0;

      if (!startedExt) {
        const flowUsedTempo = Math.min(flowAvail, Qtempo);
        emulCons = flowUsedTempo * conc;
      } else if (extRemaining > 0) {
        emulCons = Qext * conc;
        extRemaining -= 1;
      }

      if (emulCons > emulStock) emulCons = emulStock;
      emulStock -= emulCons;

      flowAvailSerie[t] = flowAvail;
      emulSerie[t] = emulStock;
    }

    const labels = buildTimeLabels(t0Abs);
    const tExtEnd = (tExtStart !== null) ? (tExtStart + tExt) : null;

    return {
      Qext, Qtempo, tExt,
      concPct: params.concPct,
      needExtTotal,
      t0Abs,
      labels,
      tStockOK,
      tExtStart,
      tExtEnd,
      flowAvailSerie,
      emulSerie
    };
  }

// ===== Dessin =====
function drawChart(data) {
  const c = $("chart");
  const ctx = c.getContext("2d");
  const W = c.width, H = c.height;
  ctx.clearRect(0, 0, W, H);

  // Marges (réduit l’espace sous l’axe X)
  const mL = 88, mR = 92, mT = 58, mB = 72; // <-- mB réduit
  const plotW = W - mL - mR;
  const plotH = H - mT - mB;

  const xMax = HORIZON_MIN;

  const maxFlow = Math.max(data.Qext, ...data.flowAvailSerie) || 1000;
  const yFlowMax = maxFlow * 1.15;

  const maxEmul = Math.max(...data.emulSerie, data.needExtTotal, 1);
  const yEmulMax = maxEmul * 1.15;

  const x = (t) => mL + (t / xMax) * plotW;
  const yFlow = (v) => mT + (1 - (v / yFlowMax)) * plotH;
  const yEmul = (v) => mT + (1 - (v / yEmulMax)) * plotH;

  // Helpers temps
  const pad2 = (n) => String(n).padStart(2, "0");
  const t0Str = `${pad2(Math.floor(data.t0Abs / 60))}:${pad2(data.t0Abs % 60)}`;
  const labelAt = (tMin) => addMinToHHMM(t0Str, tMin);

  // roundRect compat
  if (!ctx.roundRect) {
    ctx.roundRect = function (x0, y0, w, h, r) {
      const rr = Math.min(r, w / 2, h / 2);
      this.beginPath();
      this.moveTo(x0 + rr, y0);
      this.arcTo(x0 + w, y0, x0 + w, y0 + h, rr);
      this.arcTo(x0 + w, y0 + h, x0, y0 + h, rr);
      this.arcTo(x0, y0 + h, x0, y0, rr);
      this.arcTo(x0, y0, x0 + w, y0, rr);
      this.closePath();
      return this;
    };
  }

  // === Cadre ===
  ctx.lineWidth = 1;
  ctx.strokeStyle = "#cbd5e1";
  ctx.strokeRect(mL, mT, plotW, plotH);

  // === Grille verticale (20 min) ===
  ctx.strokeStyle = "#e5e7eb";
  for (let t = 0; t <= HORIZON_MIN; t += STEP_MIN) {
    ctx.beginPath();
    ctx.moveTo(x(t), mT);
    ctx.lineTo(x(t), mT + plotH);
    ctx.stroke();
  }

  // === Axe X labels ===
  ctx.fillStyle = "#111";
  ctx.font = "12px system-ui, Arial";
  for (let t = 0; t <= HORIZON_MIN; t += STEP_MIN) {
    const idx = Math.round(t / STEP_MIN);
    const label = data.labels[idx] || "";
    ctx.fillText(label, x(t) - 16, mT + plotH + 20);
  }

  // ❌ On supprime le texte sous la courbe "Temps (T0 → ...)" :
  // ctx.fillText(`Temps (T0 → T0+${HORIZON_H}h, pas ${STEP_MIN} min)`, mL, H - 18);

  // === Axe Y gauche (valeurs proches de l’axe) ===
  ctx.fillStyle = "#111";
  ctx.fillText("Débit solution (L/min)", mL, mT - 16); // aligné comme "Stock émulseur"
  for (let i = 0; i <= 5; i++) {
    const v = (yFlowMax * i / 5);
    const yy = yFlow(v);

    ctx.strokeStyle = "#e5e7eb";
    ctx.beginPath(); ctx.moveTo(mL, yy); ctx.lineTo(mL + plotW, yy); ctx.stroke();

    ctx.fillStyle = "#111";
    ctx.fillText(Math.round(v).toString(), mL - 40, yy + 4); // <-- plus proche de l’axe
  }

  // === Axe Y droit (valeurs + titre en rouge) ===
  ctx.font = "12px system-ui, Arial";
  for (let i = 0; i <= 5; i++) {
    const v = (yEmulMax * i / 5);
    const yy = yEmul(v);
    ctx.fillStyle = "#ef4444"; // valeurs en rouge
    ctx.fillText(Math.round(v).toString(), mL + plotW + 12, yy + 4); // <-- plus proche de l’axe droit
  }

  // Titre "Stock émulseur (L)" aligné avec "Débit solution"
  ctx.fillStyle = "#ef4444";
  ctx.fillText("Stock émulseur (L)", mL + plotW - 118, mT - 16);

  // === Bande extinction (vert clair) ===
  if (Number.isFinite(data.tExtStart) && Number.isFinite(data.tExtEnd)) {
    const x1 = x(data.tExtStart);
    const x2 = x(Math.min(data.tExtEnd, HORIZON_MIN));
    ctx.fillStyle = "rgba(34,197,94,0.10)";
    ctx.fillRect(x1, mT, Math.max(0, x2 - x1), plotH);
  }

  // === NOIR : débit dispo (escaliers) ===
  ctx.strokeStyle = "#111";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(x(0), yFlow(data.flowAvailSerie[0] || 0));
  for (let t = 1; t <= HORIZON_MIN; t++) {
    const prev = data.flowAvailSerie[t - 1] || 0;
    const cur = data.flowAvailSerie[t] || 0;
    const xx = x(t);
    ctx.lineTo(xx, yFlow(prev));
    if (cur !== prev) ctx.lineTo(xx, yFlow(cur));
  }
  ctx.stroke();

  // === ROUGE : stock émulseur (escaliers) ===
  ctx.strokeStyle = "#ef4444";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(x(0), yEmul(data.emulSerie[0] || 0));
  for (let t = 1; t <= HORIZON_MIN; t++) {
    const prev = data.emulSerie[t - 1] || 0;
    const cur = data.emulSerie[t] || 0;
    const xx = x(t);
    ctx.lineTo(xx, yEmul(prev));
    if (cur !== prev) ctx.lineTo(xx, yEmul(cur));
  }
  ctx.stroke();

  // === Débit cible Qext (bleu pointillés) ===
  ctx.strokeStyle = "#2563eb";
  ctx.setLineDash([6, 6]);
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(mL, yFlow(data.Qext));
  ctx.lineTo(mL + plotW, yFlow(data.Qext));
  ctx.stroke();
  ctx.setLineDash([]);

  // === Volume émulseur extinction (cible) (vert pointillés) ===
  ctx.strokeStyle = "#16a34a";
  ctx.setLineDash([6, 6]);
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(mL, yEmul(data.needExtTotal));
  ctx.lineTo(mL + plotW, yEmul(data.needExtTotal));
  ctx.stroke();
  ctx.setLineDash([]);

  // === Lignes verticales extinction (vertes) ===
  function drawVLine(tMin, color) {
    if (!Number.isFinite(tMin)) return;
    const xx = x(tMin);
    ctx.strokeStyle = color;
    ctx.setLineDash([4, 4]);
    ctx.lineWidth = 2;
    ctx.beginPath();
    ctx.moveTo(xx, mT);
    ctx.lineTo(xx, mT + plotH);
    ctx.stroke();
    ctx.setLineDash([]);
  }
  drawVLine(data.tExtStart, "#16a34a");
  drawVLine(data.tExtEnd, "#16a34a");

  // ========= Pastilles fixes sous l’axe X (plus haut + non superposées) =========
  // Encadré pointillé remonte (moins d’espace vide)
  const hintY = mT + plotH + 18; // <-- plus proche de l’axe X
  ctx.strokeStyle = "#cbd5e1";
  ctx.setLineDash([4, 4]);
  ctx.lineWidth = 1.2;
  ctx.beginPath();
  ctx.moveTo(mL, hintY);
  ctx.lineTo(mL + plotW, hintY);
  ctx.stroke();
  ctx.setLineDash([]);

  function pillBox(xCenter, yTop, text) {
    ctx.font = "12px system-ui, Arial";
    const padX = 10;
    const w = ctx.measureText(text).width + padX * 2;
    const h = 22;
    const x0 = Math.round(xCenter - w / 2);
    const y0 = Math.round(yTop);

    ctx.fillStyle = "rgba(22,163,74,0.12)";
    ctx.strokeStyle = "#16a34a";
    ctx.lineWidth = 1.5;
    ctx.roundRect(x0, y0, w, h, 12);
    ctx.fill();
    ctx.stroke();

    ctx.fillStyle = "#166534";
    ctx.fillText(text, x0 + padX, y0 + 15);
  }

  // Position des pastilles : fixes, dans la zone libre, sans collision
  const pillsY = hintY + 10; // <-- remonte (avant tu étais plus bas)
  const p1X = mL + plotW * 0.40;
  const p2X = mL + plotW * 0.60;

  const startTxt = Number.isFinite(data.tExtStart) ? `Début ext. : ${labelAt(data.tExtStart)}` : "Début ext. : —";
  const endTxt   = Number.isFinite(data.tExtEnd)   ? `Fin ext. : ${labelAt(data.tExtEnd)}`   : "Fin ext. : —";

  pillBox(p1X, pillsY, startTxt);
  pillBox(p2X, pillsY, endTxt);

  // ========= LÉGENDE (ordre demandé) =========
  const legendX = mL + 10;
  const legendY = mT + 14;

  function legendItem(x0, y0, color, label, dash = null) {
    ctx.strokeStyle = color;
    ctx.lineWidth = 3;
    if (dash) ctx.setLineDash(dash);
    ctx.beginPath();
    ctx.moveTo(x0, y0);
    ctx.lineTo(x0 + 26, y0);
    ctx.stroke();
    ctx.setLineDash([]);

    ctx.fillStyle = "#111";
    ctx.font = "12px system-ui, Arial";
    ctx.fillText(label, x0 + 32, y0 + 4);
  }

  // fond légende
  const boxW = 860;
  const boxH = 24;
  ctx.fillStyle = "rgba(255,255,255,0.85)";
  ctx.strokeStyle = "#e5e7eb";
  ctx.lineWidth = 1;
  ctx.roundRect(legendX - 8, legendY - 14, boxW, boxH, 10);
  ctx.fill();
  ctx.stroke();

  // Ordre demandé :
  legendItem(legendX + 0,   legendY, "#111",     "Débit dispo (somme engins)");
  legendItem(legendX + 250, legendY, "#2563eb",  "Débit cible (Q ext)", [6, 6]);
  legendItem(legendX + 440, legendY, "#ef4444",  "Stock émulseur dispo");
  legendItem(legendX + 620, legendY, "#16a34a",  "Volume émulseur extinction (cible)", [6, 6]);
}



  // ===== Tracer =====
  $("btnTracer").addEventListener("click", () => {
    if (rows.length === 0) { alert("Ajoute au moins un engin (ex : 1 FPT à 00:00)."); return; }

    let data;
    try { data = simulate(); }
    catch (e) { alert(e.message || "Erreur simulation."); return; }

    $("pillQext").textContent = `Q ext : ${Math.round(data.Qext)} L/min`;
    $("pillQtempo").textContent = `Q tempo : ${Math.round(data.Qtempo)} L/min`;
    $("pilltExt").textContent = `Durée ext. : ${Math.round(data.tExt)} min`;
    $("pillBesoin").textContent = `Besoin en émulseur pour extinction : ${Math.round(data.needExtTotal)} L`;
    $("pillT0").textContent = `T0 : ${minToHHMM(data.t0Abs)}`;

    const t0Str = minToHHMM(data.t0Abs);

    $("pillStockOK").textContent =
      (data.tStockOK === null) ? "Stock OK : —" : `Stock OK : ${addMinToHHMM(t0Str, data.tStockOK)}`;

    $("pillExtStart").textContent =
      (data.tExtStart === null) ? "Début extinction : —" : `Début extinction : ${addMinToHHMM(t0Str, data.tExtStart)}`;

    $("pillExtEnd").textContent =
      (data.tExtEnd === null) ? "Fin extinction : —" : `Fin extinction : ${addMinToHHMM(t0Str, data.tExtEnd)}`;

    // ✅ Indicateurs FIXES sous l’axe du temps (jamais de superposition)
    const extIndStart = $("extIndStart");
    const extIndEnd = $("extIndEnd");
    if (extIndStart && extIndEnd) {
      extIndStart.textContent =
        (data.tExtStart === null) ? "Début ext. : —" : `Début ext. : ${addMinToHHMM(t0Str, data.tExtStart)}`;
      extIndEnd.textContent =
        (data.tExtEnd === null) ? "Fin ext. : —" : `Fin ext. : ${addMinToHHMM(t0Str, data.tExtEnd)}`;
    }

    blocCourbe.style.display = "block";
    drawChart(data);
    blocCourbe.scrollIntoView({ behavior: "smooth", block: "start" });
  });

  render();
})();
</script>


</body>
</html>
