<!doctype html>
<html lang="fr">
<head>
  <meta charset="utf-8">
  <title>CMP – Courbe de montée en puissance (SDIS 27)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <style>
    body{ margin:0; font-family:system-ui, Arial, sans-serif; background:#f5f7fa; color:#111; line-height:1.5; }
    header{ background:#0b1220; color:#fff; padding:18px 14px; display:flex; align-items:center; justify-content:space-between; gap:12px; }
    header .title{ font-weight:900; font-size:1.1rem; }
    header a{ color:#fff; text-decoration:none; font-weight:800; padding:10px 12px; border-radius:10px; background:rgba(255,255,255,0.12); white-space:nowrap; }
    main{ max-width:980px; margin:auto; padding:16px 12px 26px; }
    .card{ background:#fff; border:1px solid #ddd; border-radius:14px; padding:14px; margin-top:12px; }
    .card h2{ margin:0 0 10px 0; font-size:1.1rem; font-weight:900; }
    .grid{ display:grid; grid-template-columns: 1fr 1fr 1fr 1fr; gap:10px; align-items:end; }
    @media (max-width:720px){ .grid{ grid-template-columns: 1fr 1fr; } }
    label{ font-weight:800; font-size:0.95rem; }
    input, select, button{ width:100%; padding:10px; border-radius:10px; border:1px solid #ccc; box-sizing:border-box; font-family:inherit; font-size:1rem; }
    .row{ display:flex; gap:10px; margin-top:10px; flex-wrap:wrap; }
    .btn{ cursor:pointer; font-weight:900; border:0; border-radius:12px; padding:12px 14px; }
    .btn-primary{ background:#2563eb; color:#fff; }
    .btn-ghost{ background:#fff; border:1px solid #ccc; }
    .small{ font-size:12px; color:#555; margin-top:6px; }
    .warn{ background:#fff3cd; border:1px solid #ffeeba; padding:10px 12px; border-radius:12px; font-size:0.95rem; }

    table{ width:100%; border-collapse:separate; border-spacing:0; overflow:hidden; border:1px solid #e5e7eb; border-radius:12px; margin-top:10px; }
    th, td{ padding:10px; border-bottom:1px solid #e5e7eb; text-align:left; font-size:0.95rem; vertical-align:middle; }
    th{ background:#f8fafc; font-weight:900; }
    tr:last-child td{ border-bottom:none; }

    .pill{ display:inline-block; padding:6px 10px; border-radius:999px; font-weight:900; font-size:0.85rem; border:1px solid #ddd; background:#f8fafc; }

    .canvas-wrap{ width:100%; overflow:auto; border:1px dashed #cbd5e1; border-radius:12px; padding:10px; background:#fff; }
    canvas{ width:100%; height:auto; }
  </style>
</head>

<body>
<header>
  <div class="title">CMP – Courbe de montée en puissance (SDIS 27)</div>
  <a href="calcul.html">← Retour calcul</a>
</header>

<main>
  <div class="card" id="blocStatus">
    <h2>Paramètres importés depuis le calcul</h2>
    <div id="status" class="warn">Chargement…</div>
    <div class="small">La CMP est disponible uniquement si tu viens depuis le calcul en mode SDIS 27.</div>
  </div>

  <div class="card" id="blocSaisie" style="display:none;">
    <h2>Saisie des engins (arrivée échelonnée)</h2>

    <div class="grid">
      <div>
        <label>Type d’engin</label>
        <select id="enginType">
          <option value="FPT">FPT</option>
          <option value="CCRM">CCRM</option>
          <option value="CCR">CCR</option>
          <option value="CCGC">CCGC</option>
          <option value="CCGCM">CCGCM</option>
          <option value="CED">CED</option>
          <option value="CEDEM">CEDEM</option>
          <option value="CDHR">CDHR</option>
          <option value="CEEM">CEEM (émulseur)</option>
        </select>
        <div class="small">Débit solution + stock émulseur selon table SDIS 27.</div>
      </div>

      <div>
        <label>Heure d’arrivée (hh:mm)</label>
        <input id="arrivee" type="time" value="00:00">
        <div class="small">00:00 = sur place immédiat.</div>
      </div>

      <div>
        <label>Quantité</label>
        <input id="qty" type="number" min="1" step="1" value="1">
      </div>

      <div>
        <button id="btnAdd" class="btn btn-primary" type="button">Ajouter</button>
      </div>
    </div>

    <table>
      <thead>
        <tr>
          <th>Type</th>
          <th>Arrivée</th>
          <th>Qté</th>
          <th>Débit (L/min)</th>
          <th>Émulseur (L)</th>
          <th></th>
        </tr>
      </thead>
      <tbody id="liste"></tbody>
    </table>

    <div class="row">
      <button id="btnTracer" class="btn btn-primary" type="button">Tracer la courbe</button>
      <button id="btnReset" class="btn btn-ghost" type="button">Tout effacer</button>
    </div>

    <div class="small">
      Logique : TEMPORISATION tant que débit dispo &lt; Q ext OU stock émulseur &lt; besoin extinction.
      Temporisation : conso = Q tempo × 3%. Extinction : conso = Q ext × 3% pendant Durée ext.
    </div>
  </div>

  <div class="card" id="blocCourbe" style="display:none;">
    <h2>Courbe (T0 → T0+5h, pas 20 min)</h2>
 <div class="row" style="align-items:center;">
  <span class="pill" id="pillQext">Q ext : —</span>
  <span class="pill" id="pillQtempo">Q tempo : —</span>
  <span class="pill" id="pilltExt">Durée ext. : —</span>
  <span class="pill" id="pillBesoin">Besoin en émulseur pour extinction : —</span>
  <span class="pill" id="pillT0">T0 : —</span>
  <span class="pill" id="pillExtStart">Début extinction : —</span>
  <span class="pill" id="pillExtEnd">Fin extinction : —</span>
</div>


    <div class="canvas-wrap" style="margin-top:10px;">
      <canvas id="chart" width="1100" height="520"></canvas>
    </div>

    <div class="small">
      Axe gauche : débit solution (L/min). Axe droit : stock émulseur (L). Courbes en escaliers.
      Marqueurs : Stock OK (≥ besoin extinction) et Début extinction (débit ≥ Q ext ET stock ≥ besoin).
    </div>
  </div>
</main>

<script>
(() => {
  const $ = (id) => document.getElementById(id);

  // ===== Paramètres CMP =====
  const STEP_MIN = 20;
  const HORIZON_H = 5;
  const HORIZON_MIN = HORIZON_H * 60;

  const pad2 = (x) => String(x).padStart(2, "0");

  const n = (v) => {
    if (v === null || v === undefined) return NaN;
    const s = String(v).replace(",", ".").trim();
    if (!s) return NaN;
    const x = Number(s);
    return Number.isFinite(x) ? x : NaN;
  };

  const timeToMin = (hhmm) => {
    if (!hhmm || !/^\d{2}:\d{2}$/.test(hhmm)) return NaN;
    const [h, m] = hhmm.split(":").map(Number);
    if (h < 0 || h > 23 || m < 0 || m > 59) return NaN;
    return h * 60 + m;
  };

  const addMinToHHMM = (hhmm, add) => {
    const base = timeToMin(hhmm);
    if (!Number.isFinite(base)) return "??:??";
    let total = (base + add) % (24 * 60);
    if (total < 0) total += 24 * 60;
    const h = Math.floor(total / 60);
    const m = total % 60;
    return `${pad2(h)}:${pad2(m)}`;
  };

  const getFirstArrivalMin = (rows) => {
    let best = Infinity;
    rows.forEach(r => {
      const m = timeToMin(r.atStr);
      if (Number.isFinite(m)) best = Math.min(best, m);
    });
    return best === Infinity ? NaN : best;
  };

  const arrivalRelMin = (hhmm, t0) => {
    const m = timeToMin(hhmm);
    if (!Number.isFinite(m) || !Number.isFinite(t0)) return NaN;
    let rel = m - t0;
    if (rel < 0) rel += 24 * 60; // passage minuit
    return rel;
  };

  const buildTimeLabels = (t0MinAbs) => {
    const t0 = `${pad2(Math.floor(t0MinAbs / 60))}:${pad2(t0MinAbs % 60)}`;
    const labels = [];
    for (let t = 0; t <= HORIZON_MIN; t += STEP_MIN) labels.push(addMinToHHMM(t0, t));
    return labels;
  };

  // ===== Table SDIS 27 : débit solution (L/min) et stock émulseur (L) =====
  const ENGINS = {
    FPT:   { flow: 2000, emul: 200 },
    CCRM:  { flow: 1500, emul: 200 },
    CCR:   { flow: 1000, emul: 40  },
    CCGC:  { flow: 1000, emul: 0   },
    CCGCM: { flow: 3000, emul: 1200 },
    CED:   { flow: 4000, emul: 0   },
    CEDEM: { flow: 4000, emul: 2000 },
    CDHR:  { flow: 4000, emul: 0   },
    CEEM:  { flow: 0,    emul: 6000 }
  };

  // ===== Charge paramètres calcul =====
  let params = null;
  try {
    params = JSON.parse(localStorage.getItem("LIF_CMP_INPUTS") || "null");
  } catch (e) { params = null; }

  const status = $("status");
  const blocSaisie = $("blocSaisie");
  const blocCourbe = $("blocCourbe");

  if (!params || params.mode !== "lock") {
    status.textContent = "Impossible : aucun calcul SDIS 27 n’a été transmis. Retourne sur la page calcul, fais un calcul en mode SDIS 27, puis clique sur “Courbe de montée en puissance”.";
    return;
  }

  status.innerHTML =
    `✅ Paramètres reçus :<br>
     - Q ext = <b>${Math.round(params.Qext)}</b> L/min<br>
     - Q tempo = <b>${Math.round(params.Qtempo)}</b> L/min<br>
     - Durée ext. = <b>${Math.round(params.tExt)}</b> min<br>
     - Concentration = <b>${params.concPct}%</b><br>
     - Besoin extinction = <b>${Math.round(params.besoinExt)}</b> L émulseur`;
  blocSaisie.style.display = "block";

  // ===== Liste d'engins =====
  const rows = []; // {type, atStr, qty}
  const tbody = $("liste");

  const render = () => {
    tbody.innerHTML = "";
    rows.forEach((r, idx) => {
      const def = ENGINS[r.type];
      const flow = def.flow * r.qty;
      const emul = def.emul * r.qty;

      const tr = document.createElement("tr");
      tr.innerHTML = `
        <td><b>${r.type}</b></td>
        <td>${r.atStr}</td>
        <td>${r.qty}</td>
        <td>${flow}</td>
        <td>${emul}</td>
        <td><button data-i="${idx}" class="btn btn-ghost" style="padding:8px 10px;">Supprimer</button></td>
      `;
      tbody.appendChild(tr);
    });

    tbody.querySelectorAll("button[data-i]").forEach(btn => {
      btn.addEventListener("click", () => {
        const i = Number(btn.getAttribute("data-i"));
        rows.splice(i, 1);
        render();
      });
    });
  };

  $("btnAdd").addEventListener("click", () => {
    const type = $("enginType").value;
    const atStr = $("arrivee").value || "00:00";
    const qty = Math.max(1, Math.floor(n($("qty").value) || 1));

    if (!ENGINS[type]) return;
    if (!Number.isFinite(timeToMin(atStr))) { alert("Heure d’arrivée invalide."); return; }

    rows.push({ type, atStr, qty });
    rows.sort((a,b) => timeToMin(a.atStr) - timeToMin(b.atStr));
    render();
  });

  $("btnReset").addEventListener("click", () => {
    rows.length = 0;
    render();
    blocCourbe.style.display = "none";
  });

  // ===== Simulation minute par minute (T0 → T0+5h) =====
function simulate() {
  const Qext = params.Qext;          // L/min
  const Qtempo = params.Qtempo;      // L/min
  const tExt = params.tExt;          // min
  const conc = (params.concPct / 100);

  const needExtTotal = Qext * tExt * conc; // L d’émulseur nécessaires

  const t0Abs = getFirstArrivalMin(rows);
  if (!Number.isFinite(t0Abs)) throw new Error("Impossible : aucune arrivée valide.");

  const addFlow = Array(HORIZON_MIN + 1).fill(0);
  const addEmul = Array(HORIZON_MIN + 1).fill(0);

  rows.forEach(r => {
    const def = ENGINS[r.type];
    const rel = arrivalRelMin(r.atStr, t0Abs);
    if (!Number.isFinite(rel)) return;

    const m = Math.min(HORIZON_MIN, Math.max(0, Math.round(rel)));
    addFlow[m] += def.flow * r.qty;
    addEmul[m] += def.emul * r.qty;
  });

  let flowAvail = 0;
  let emulStock = 0;

  let startedExt = false;
  let extRemaining = 0;

  let tStockOK = null;
  let tExtStart = null;

  const flowAvailSerie = Array(HORIZON_MIN + 1).fill(0); // NOIR (escaliers)
  const emulSerie = Array(HORIZON_MIN + 1).fill(0);      // ROUGE (escaliers)

  for (let t = 0; t <= HORIZON_MIN; t++) {
    // Arrivées => marches immédiates
    flowAvail += addFlow[t];
    emulStock += addEmul[t];

    // repère "stock OK"
    if (tStockOK === null && emulStock >= needExtTotal) tStockOK = t;

    // Conditions extinction
    const canFlow = flowAvail >= Qext;
    const canEmul = emulStock >= needExtTotal;

    if (!startedExt && canFlow && canEmul) {
      startedExt = true;
      extRemaining = tExt;
      tExtStart = t;
    }

    // ===== consommation d’émulseur =====
    let emulCons = 0;

    if (!startedExt) {
      // ✅ TEMPORISATION : on ne peut pas "consommer dans le vide"
      const flowUsedTempo = Math.min(flowAvail, Qtempo);
      emulCons = flowUsedTempo * conc;
    } else if (extRemaining > 0) {
      // EXTINCTION : conso = Qext × 3% pendant tExt
      emulCons = Qext * conc;
      extRemaining -= 1;
    } else {
      emulCons = 0;
    }

    // on ne consomme pas au-delà du stock
    if (emulCons > emulStock) emulCons = emulStock;
    emulStock -= emulCons;

    flowAvailSerie[t] = flowAvail;
    emulSerie[t] = emulStock;
  }

  const labels = buildTimeLabels(t0Abs);
  
// Fin extinction = début extinction + durée extinction
const tExtEnd = (tExtStart !== null) ? (tExtStart + tExt) : null;

return {
  Qext,
  Qtempo,
  tExt,
  concPct: params.concPct,
  needExtTotal,
  t0Abs,
  labels,
  tStockOK,
  tExtStart,
  tExtEnd,
  flowAvailSerie,
  emulSerie
};

}

  // ===== Dessin canvas (escaliers) =====
function drawChart(data) {
  const c = $("chart");
  const ctx = c.getContext("2d");
  const W = c.width, H = c.height;
  ctx.clearRect(0, 0, W, H);

  // Marges (plus de place sous l’axe X => plus de superposition)
  const mL = 95, mR = 105, mT = 42, mB = 100;
  const plotW = W - mL - mR;
  const plotH = H - mT - mB;

  const xMax = HORIZON_MIN;

  const maxFlow = Math.max(data.Qext, ...data.flowAvailSerie) || 1000;
  const yFlowMax = maxFlow * 1.15;

  const maxEmul = Math.max(...data.emulSerie, data.needExtTotal, 1);
  const yEmulMax = maxEmul * 1.15;

  const x = (t) => mL + (t / xMax) * plotW;
  const yFlow = (v) => mT + (1 - (v / yFlowMax)) * plotH;
  const yEmul = (v) => mT + (1 - (v / yEmulMax)) * plotH;

  // Cadre
  ctx.lineWidth = 1;
  ctx.strokeStyle = "#cbd5e1";
  ctx.strokeRect(mL, mT, plotW, plotH);

  // Grille verticale (20 min)
  ctx.strokeStyle = "#e5e7eb";
  for (let t = 0; t <= HORIZON_MIN; t += STEP_MIN) {
    ctx.beginPath();
    ctx.moveTo(x(t), mT);
    ctx.lineTo(x(t), mT + plotH);
    ctx.stroke();
  }

  // Axe X labels (hh:mm)
  ctx.fillStyle = "#111";
  ctx.font = "12px system-ui, Arial";
  for (let t = 0; t <= HORIZON_MIN; t += STEP_MIN) {
    const idx = Math.round(t / STEP_MIN);
    const label = data.labels[idx] || "";
    ctx.fillText(label, x(t) - 18, mT + plotH + 22);
  }
  ctx.fillText(`Temps (T0 → T0+${HORIZON_H}h, pas ${STEP_MIN} min)`, mL, H - 18);

  // Axe Y gauche
  ctx.fillStyle = "#111";
  ctx.fillText("Débit solution (L/min)", 10, 18);
  for (let i = 0; i <= 5; i++) {
    const v = (yFlowMax * i / 5);
    const yy = yFlow(v);
    ctx.strokeStyle = "#e5e7eb";
    ctx.beginPath(); ctx.moveTo(mL, yy); ctx.lineTo(mL + plotW, yy); ctx.stroke();
    ctx.fillStyle = "#111";
    ctx.fillText(Math.round(v).toString(), 10, yy + 4);
  }

  // Axe Y droit
  ctx.fillStyle = "#111";
  ctx.fillText("Stock émulseur (L)", W - 230, 18);
  for (let i = 0; i <= 5; i++) {
    const v = (yEmulMax * i / 5);
    const yy = yEmul(v);
    ctx.fillText(Math.round(v).toString(), W - 90, yy + 4);
  }

  // ✅ Bande "phase extinction" (si on a un début)
  if (Number.isFinite(data.tExtStart) && Number.isFinite(data.tExtEnd)) {
    const x1 = x(data.tExtStart);
    const x2 = x(Math.min(data.tExtEnd, HORIZON_MIN));
    ctx.fillStyle = "rgba(34,197,94,0.10)"; // vert léger
    ctx.fillRect(x1, mT, Math.max(0, x2 - x1), plotH);
  }

  // ✅ NOIR = débit dispo (escaliers)
  ctx.strokeStyle = "#111";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(x(0), yFlow(data.flowAvailSerie[0] || 0));
  for (let t = 1; t <= HORIZON_MIN; t++) {
    const prev = data.flowAvailSerie[t - 1] || 0;
    const cur = data.flowAvailSerie[t] || 0;
    const xx = x(t);
    ctx.lineTo(xx, yFlow(prev));
    if (cur !== prev) ctx.lineTo(xx, yFlow(cur));
  }
  ctx.stroke();

  // ✅ ROUGE = stock émulseur (escaliers)
  ctx.strokeStyle = "#ef4444";
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(x(0), yEmul(data.emulSerie[0] || 0));
  for (let t = 1; t <= HORIZON_MIN; t++) {
    const prev = data.emulSerie[t - 1] || 0;
    const cur = data.emulSerie[t] || 0;
    const xx = x(t);
    ctx.lineTo(xx, yEmul(prev));
    if (cur !== prev) ctx.lineTo(xx, yEmul(cur));
  }
  ctx.stroke();

  // ✅ Ligne cible Qext (bleu pointillés)
  ctx.strokeStyle = "#2563eb";
  ctx.setLineDash([6, 6]);
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(mL, yFlow(data.Qext));
  ctx.lineTo(mL + plotW, yFlow(data.Qext));
  ctx.stroke();
  ctx.setLineDash([]);

  // ✅ Besoin émulseur extinction (vert pointillés)
  ctx.strokeStyle = "#16a34a";
  ctx.setLineDash([6, 6]);
  ctx.lineWidth = 2;
  ctx.beginPath();
  ctx.moveTo(mL, yEmul(data.needExtTotal));
  ctx.lineTo(mL + plotW, yEmul(data.needExtTotal));
  ctx.stroke();
  ctx.setLineDash([]);

  // Helpers temps
  const pad2 = (n) => String(n).padStart(2, "0");
  const t0Str = `${pad2(Math.floor(data.t0Abs / 60))}:${pad2(data.t0Abs % 60)}`;
  const labelAt = (tMin) => addMinToHHMM(t0Str, tMin);

  // ✅ Marqueurs verticaux (on met les libellés EN HAUT dans le graphe => plus de superposition)
  function drawMarkerTop(tMin, text, color) {
    if (!Number.isFinite(tMin)) return;

    const xx = x(tMin);

    // ligne verticale
    ctx.strokeStyle = color;
    ctx.setLineDash([4, 4]);
    ctx.lineWidth = 1.5;
    ctx.beginPath();
    ctx.moveTo(xx, mT);
    ctx.lineTo(xx, mT + plotH);
    ctx.stroke();
    ctx.setLineDash([]);

    // petit cartouche en haut
    ctx.font = "12px system-ui, Arial";
    const pad = 6;
    const w = ctx.measureText(text).width + pad * 2;
    const boxX = Math.min(W - mR - w - 4, Math.max(mL + 4, xx + 6));
    const boxY = mT + 6;

    ctx.fillStyle = "rgba(255,255,255,0.92)";
    ctx.strokeStyle = color;
    ctx.lineWidth = 1;
    ctx.beginPath();
    ctx.roundRect(boxX, boxY, w, 22, 8);
    ctx.fill();
    ctx.stroke();

    ctx.fillStyle = color;
    ctx.fillText(text, boxX + pad, boxY + 15);
  }

  // Stock OK (vert)
  if (data.tStockOK !== null) {
    drawMarkerTop(data.tStockOK, `Stock OK : ${labelAt(data.tStockOK)}`, "#16a34a");
  }

  // Début extinction (bleu foncé)
  if (data.tExtStart !== null) {
    drawMarkerTop(data.tExtStart, `Début ext. : ${labelAt(data.tExtStart)}`, "#0f172a");
  }

  // Fin extinction (bleu foncé)
  if (data.tExtEnd !== null) {
    drawMarkerTop(data.tExtEnd, `Fin ext. : ${labelAt(data.tExtEnd)}`, "#0f172a");
  }

  // Légende
  ctx.fillStyle = "#111";
  ctx.font = "12px system-ui, Arial";
  ctx.fillText("— Débit dispo (somme engins)", mL + 10, mT + 16);
  ctx.fillStyle = "#ef4444";
  ctx.fillText("— Stock émulseur dispo", mL + 230, mT + 16);
  ctx.fillStyle = "#2563eb";
  ctx.fillText("— Q ext (cible)", mL + 390, mT + 16);
  ctx.fillStyle = "#16a34a";
  ctx.fillText("— Besoin en émulseur pour extinction", mL + 510, mT + 16);
}



  // ===== Action tracer =====
  $("btnTracer").addEventListener("click", () => {
    if (rows.length === 0) { alert("Ajoute au moins un engin (ex : 1 FPT à 00:00)."); return; }

    let data;
    try { data = simulate(); }
    catch (e) { alert(e.message || "Erreur simulation."); return; }

    const t0HHMM = `${pad2(Math.floor(data.t0Abs / 60))}:${pad2(data.t0Abs % 60)}`;

    $("pillQext").textContent = `Q ext : ${Math.round(data.Qext)} L/min`;
    $("pillQtempo").textContent = `Q tempo : ${Math.round(data.Qtempo)} L/min`;
    $("pilltExt").textContent = `Durée ext. : ${Math.round(data.tExt)} min`;
   $("pillBesoin").textContent = `Besoin en émulseur pour extinction : ${Math.round(data.needExtTotal)} L`;
$("pillT0").textContent = `T0 : ${minToHHMM(data.t0Abs)}`;

// Début / fin extinction (si atteinte)
if (Number.isFinite(data.tExtStart)) {
  const t0Str = `${String(Math.floor(data.t0Abs/60)).padStart(2,"0")}:${String(data.t0Abs%60).padStart(2,"0")}`;
  const startHHMM = addMinToHHMM(t0Str, data.tExtStart);
  $("pillExtStart").textContent = `Début extinction : ${startHHMM}`;
} else {
  $("pillExtStart").textContent = "Début extinction : —";
}

if (Number.isFinite(data.tExtEnd)) {
  const t0Str = `${String(Math.floor(data.t0Abs/60)).padStart(2,"0")}:${String(data.t0Abs%60).padStart(2,"0")}`;
  const endHHMM = addMinToHHMM(t0Str, data.tExtEnd);
  $("pillExtEnd").textContent = `Fin extinction : ${endHHMM}`;
} else {
  $("pillExtEnd").textContent = "Fin extinction : —";
}


    const stockOK = (data.tStockOK === null) ? "—" : addMinToHHMM(t0HHMM, data.tStockOK);
    const extStart = (data.tExtStart === null) ? "—" : addMinToHHMM(t0HHMM, data.tExtStart);

    $("pillStockOK").textContent = `Stock OK : ${stockOK}`;
    $("pillExtStart").textContent = `Début ext. : ${extStart}`;

    blocCourbe.style.display = "block";
    drawChart(data);
    blocCourbe.scrollIntoView({ behavior: "smooth", block: "start" });
  });

  render();
})();
</script>

</body>
</html>
